// Sin Module
`timescale 1ns/1ps

// nBitReg: n–bit register with parameterized initial value
module nBitReg #(
  parameter n = 16,
  parameter [n-1:0] INIT_VALUE = {n{1'b0}}
) (
  input                clk,
  input                rst,
  input                init,  // load initial value
  input                load,  // load new value
  input  [n - 1:0]     in,
  output reg [n - 1:0] out
);
  always @(posedge clk or posedge rst)
    if (rst)
      out <= 0;
    else if (init)
      out <= INIT_VALUE;
    else if (load)
      out <= in;
endmodule

// cntReg: m–bit counter (used to count iterations)
module cntReg #(
  parameter m = 3
) (
  input              clk,
  input              rst,
  input              cntUp,
  input              init0,
  output reg [m - 1:0] cnt
);
  always @(posedge clk or posedge rst)
    if (rst)
      cnt <= 0;
    else if (init0)
      cnt <= 0;
    else if (cntUp)
      cnt <= cnt + 1;
endmodule

// sineLUT: Contains reciprocal factorial coefficients for sin(x)
// Coefficients for iterations:
//  address 0: 1/3! ≈ 0.16666 (16'h2AAA)
//  address 1: 1/5! ≈ 0.0083333 (16'h0222)
//  address 2: 1/7! ≈ 0.00019841 (16'h000D)
//  address 3-7: 0
module sineLUT (
  input  [2:0] addr,
  output [15:0] out
);
  reg [15:0] dataOut;
  always @(*) begin
    case(addr)
      3'd0: dataOut = 16'h2AAA; // 0.16666...
      3'd1: dataOut = 16'h0222; // 0.008333...
      3'd2: dataOut = 16'h000D; // 0.000198...
      3'd3: dataOut = 16'h0000;
      3'd4: dataOut = 16'h0000;
      3'd5: dataOut = 16'h0000;
      3'd6: dataOut = 16'h0000;
      3'd7: dataOut = 16'h0000;
      default: dataOut = 16'h0000;
    endcase
  end
  assign out = dataOut;
endmodule

// sineDataPathUnit: Implements the series evaluation for sin(x)
// Series: sin(x) = x - x^3/3! + x^5/5! - ...
// It uses the recurrence:
//   term[0] = x,
//   term[n+1] = term[n] * (x^2) * (LUT coefficient)
// and accumulates the sum with alternating sign.
module sineDataPathUnit (
    input         clk,
    input         rst,
    input         cntUp,
    input         init0,
    input         ldX,
    input         ldT,
    input         initT1,   // load term register with initial value
    input         initSine1, // load sine accumulator with initial value (x)
    input         ldSine,
    input         selXorI,  // selects between x^2 and LUT coefficient
    input         sub,      // if asserted, subtract the term; otherwise add
    input  [15:0] xBus,
    output        cnt8,
    output [17:0] rBus
);
    wire [2:0] cntOut;
    wire [17:0] sineOut;
    wire [15:0] lutOut, xOut, tOut, muxOut;
    wire [31:0] multResult;
    wire [15:0] multOut;

    // Instantiate counter
    cntReg #(3) cntr (
        .clk(clk), .rst(rst), .cntUp(cntUp), .init0(init0), .cnt(cntOut)
    );
    
    // Instantiate LUT for sine coefficients
    sineLUT lut (
        .addr(cntOut), .out(lutOut)
    );
    
    // x register: holds the input angle (x)
    nBitReg #(16) xReg (
        .clk(clk), .rst(rst), .init(1'b0), .load(ldX),
        .in(xBus), .out(xOut)
    );
    
    // Compute x^2 (fixed point multiplication, taking high 16 bits)
    // Note: This is a combinational multiply; adjust if pipelining is needed.
    wire [31:0] xSq_full = xBus * xBus;
    wire [15:0] xSq = xSq_full[31:16];

    // Term register: holds the current term in the series
    // For sine, initial term is x (not 1.0 as in cosine)
    nBitReg #(16, 16'h0000) tReg (
        .clk(clk), .rst(rst), .init(initT1), .load(ldT),
        .in(multOut), .out(tOut)
    );
    
    // Sine accumulator register (18-bit)
    // Initialize with the first term, x (scaled to 18 bits)
    nBitReg #(18, 18'h00000) sineReg (
        .clk(clk), .rst(rst), .init(initSine1), .load(ldSine),
        .in(addOut), .out(sineOut)
    );
    
    // Multiplexer: select multiplier input.
    // When selXorI is asserted, choose x^2; otherwise choose LUT coefficient.
    assign muxOut = (selXorI) ? xSq : lutOut;
    
    // Multiply the current term by the selected value.
    assign multResult = tOut * muxOut;
    assign multOut = multResult[31:16];

    // Compute the addition: sine accumulator + (possibly negative) term.
    // Extend tOut to 18 bits; apply sign if 'sub' is asserted.
    wire signed [17:0] termExtended = sub ? -{{2{tOut[15]}}, tOut} : {{2{tOut[15]}}, tOut};
    wire signed [17:0] sSineOut = sineOut;  // treat sineOut as signed
    // Use an extra bit for carry; then saturate if needed.
    wire signed [18:0] fullAdd = { sSineOut[17], sSineOut } + { termExtended[17], termExtended };
    wire signed [17:0] addOut =
        (fullAdd < 0) ? 18'd0 :
        (fullAdd > 18'd131071) ? 18'd131071 :
        fullAdd[17:0];

    assign cnt8 = (cntOut == 3'd7);
    assign rBus = sineOut;
endmodule

// sineControlUnit: State machine for sin(x)
// States: IDLE, INIT, ITERATE1 (multiply term by x^2),
//         ITERATE2 (multiply by LUT coefficient), SINE (update accumulator), DONE.
module sineControlUnit (
  input  clk,
  input  rst,
  input  start,
  input  cnt8,
  output reg ldX,
  output reg initT1,
  output reg initSine1,  
  output reg init0,
  output reg ldT,
  output reg ldSine,
  output reg selXorI,
  output reg cntUp,
  output reg done,
  output reg sub
);
  parameter [2:0]
    IDLE     = 3'd0,
    INIT     = 3'd1,
    ITERATE1 = 3'd2,
    ITERATE2 = 3'd3,
    SINE     = 3'd4,
    DONE     = 3'd5;
    
  reg [2:0] state, next;
  // sign register: 1 means subtract the term, 0 means add.
  // For sin(x): term0 is already added, so the first computed term should be subtracted.
  reg sign;

  // State register
  always @(posedge clk or posedge rst)
    if (rst) begin
      state <= IDLE;
      sign  <= 1'b1;  // start with subtraction for the first computed term
    end else begin
      state <= next;
      if (state == SINE)
        sign <= ~sign;
    end

  // Next-state and output logic
  always @(*) begin
    // Default assignments (all signals low)
    next      = state;
    ldX       = 0;
    initT1    = 0;
    initSine1 = 0;
    init0     = 0;
    ldT       = 0;
    ldSine    = 0;
    selXorI   = 0;
    cntUp     = 0;
    done      = 0;
    sub       = 0;
    
    case (state)
      IDLE: begin
        if(start)
          next = INIT;
        else
          next = IDLE;
      end
      INIT: begin
        // Initialize: load term with x and sine accumulator with x,
        // reset counter and load x.
        initT1    = 1;
        initSine1 = 1;
        init0     = 1;
        ldX       = 1;
        next = ITERATE1;
      end
      ITERATE1: begin
        // Multiply previous term by x^2.
        // selXorI = 1 selects x^2 (computed externally in the datapath).
        selXorI = 1;
        ldT     = 1;
        next    = ITERATE2;
      end
      ITERATE2: begin
        // Multiply by LUT coefficient (1/factorial factor) to adjust magnitude.
        selXorI = 0;
        ldT     = 1;
        next    = SINE;
      end
      SINE: begin
        // Add computed term (with sign) to sine accumulator and increment counter.
        ldSine = 1;
        cntUp  = 1;
        sub    = sign;  // use current sign flag
        if(cnt8)
          next = DONE;
        else
          next = ITERATE1;
      end
      DONE: begin
        done = 1;
        if(~start)
          next = IDLE;
        else
          next = DONE;
      end
      default: next = IDLE;
    endcase
  end
endmodule

// sineTop: Top-level module for sin(x)
module sineTop (
  input         clk,
  input         rst,
  input         start,
  input  [15:0] xBus,
  output [17:0] rBus,
  output        done
);
  wire ldX, initT1, initSine1, init0, ldT, ldSine, selXorI, cntUp, cnt8, sub;

  sineControlUnit sineControl (
    .clk(clk), .rst(rst), .start(start), .cnt8(cnt8),
    .ldX(ldX), .initT1(initT1), .initSine1(initSine1), .init0(init0),
    .ldT(ldT), .ldSine(ldSine), .selXorI(selXorI),
    .cntUp(cntUp), .done(done), .sub(sub)
  );

  sineDataPathUnit sineDataPath (
    .clk(clk), .rst(rst), .cntUp(cntUp), .init0(init0),
    .ldX(ldX), .ldT(ldT), .initT1(initT1), .initSine1(initSine1),
    .ldSine(ldSine), .selXorI(selXorI), .sub(sub), .xBus(xBus),
    .cnt8(cnt8), .rBus(rBus)
  );
endmodule
